<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pocket Ecosystems</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Architects+Daughter&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Comfortaa', cursive;
            background-color: #d1e6f9; /* Softer light sky blue */
            color: #075985; /* Darker sky blue */
            overscroll-behavior: none;
        }
        .header-font {
            font-family: 'Architects Daughter', cursive;
        }
        .panel {
            background-color: rgba(255, 255, 255, 0.92); /* Slightly more opaque */
            backdrop-filter: blur(10px);
            border: 1px solid #cce7ff; /* Softer border */
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.1);
        }
        .btn {
            background-color: #38bdf8; /* Sky blue 400 */
            color: white;
            transition: all 0.2s ease-in-out;
            border: none;
            font-weight: 600;
            padding: 0.6rem 1rem;
            border-radius: 0.375rem;
        }
        .btn:hover {
            background-color: #0ea5e9; /* Sky blue 500 */
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(2, 132, 199, 0.2);
        }
        .btn-secondary {
            background-color: #94a3b8; /* Slate 400 */
        }
        .btn-secondary:hover {
            background-color: #64748b; /* Slate 500 */
        }
        .btn-danger {
            background-color: #f87171; /* Red 400 */
        }
        .btn-danger:hover {
            background-color: #ef4444; /* Red 500 */
        }
        .palette-item {
            border: 2px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background-color: #f0f9ff; /* Sky 50 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
            border-radius: 0.375rem;
            min-height: 70px;
        }
        .palette-item:hover {
            border-color: #38bdf8;
            background-color: #e0f2fe;
        }
        .palette-item.selected {
            border-color: #0ea5e9;
            background-color: #cce7ff;
            box-shadow: 0 0 0 2px #0ea5e9;
        }
        .palette-item img, .palette-item .item-emoji {
            width: 32px; height: 32px;
            margin-bottom: 0.25rem;
            object-fit: contain;
        }
        .palette-item .item-name {
            font-size: 0.7rem;
            color: #0c4a6e; /* Sky 800 */
        }
        #ecosystemCanvas {
            border: 3px solid #a5d8f8; /* Softer Sky 300 */
            background-color: #f0f9ff; 
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        .start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .canvas-wrapper {
            position: relative;
            width: fit-content; 
            height: fit-content;
            margin: auto;
            box-shadow: 0 0 15px rgba(0,0,0,0.1); /* Subtle shadow for canvas */
        }
        #waterSurfaceCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; 
            opacity: 0.3;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-2 sm:p-4 selection:bg-sky-200 selection:text-sky-800">

    <div id="startAudioOverlay" class="start-overlay">
        <button id="startAudioButton" class="btn text-white font-bold py-4 px-8 rounded-lg text-2xl header-font bg-sky-500 hover:bg-sky-600">
            Create Your Pocket Ecosystem
        </button>
    </div>

    <header class="my-4 sm:my-6 text-center">
        <h1 class="text-3xl sm:text-4xl md:text-5xl text-sky-700 header-font">Pocket Ecosystems</h1>
    </header>

    <div class="w-full max-w-7xl grid grid-cols-1 lg:grid-cols-4 gap-4">
        <aside class="lg:col-span-1 panel p-3 sm:p-4 rounded-lg space-y-4 h-fit sticky top-4">
            <div>
                <label for="ecosystemTypeSelect" class="block text-sm font-semibold mb-1">Ecosystem Type:</label>
                <select id="ecosystemTypeSelect" class="w-full p-2 rounded-md bg-sky-50 border-sky-300 focus:border-sky-500 focus:ring-sky-500">
                    <option value="aquarium">Aquarium</option>
                    <option value="terrarium">Terrarium</option>
                </select>
            </div>
            <div id="itemPalette" class="grid grid-cols-3 gap-2 max-h-96 overflow-y-auto p-1 bg-sky-100 rounded">
                </div>
            <div class="space-y-2 pt-2 border-t border-sky-200">
                <button id="toggleDayNightButton" class="btn w-full">Toggle Day/Night</button>
                <button id="saveEcosystemButton" class="btn btn-secondary w-full">Save Ecosystem</button>
                <button id="loadEcosystemButton" class="btn btn-secondary w-full">Load Ecosystem</button>
                <button id="clearEcosystemButton" class="btn btn-danger w-full">Clear Ecosystem</button>
            </div>
        </aside>

        <main class="lg:col-span-3 panel rounded-lg p-2 sm:p-3 flex justify-center items-center">
            <div class="canvas-wrapper">
                <canvas id="ecosystemCanvas" class="rounded-md"></canvas>
                <canvas id="waterSurfaceCanvas"></canvas> </div>
        </main>
    </div>

    <footer class="mt-6 sm:mt-8 text-center text-sm text-sky-600">
        <p>&copy; <span id="currentYear"></span> Pocket Ecosystems. Nurture your digital world.</p>
    </footer>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        const startAudioOverlay = document.getElementById('startAudioOverlay');
        const startAudioButton = document.getElementById('startAudioButton');

        const canvas = document.getElementById('ecosystemCanvas');
        const ctx = canvas.getContext('2d');
        const waterSurfaceCanvas = document.getElementById('waterSurfaceCanvas');
        const waterCtx = waterSurfaceCanvas.getContext('2d');

        const ecosystemTypeSelect = document.getElementById('ecosystemTypeSelect');
        const itemPaletteDiv = document.getElementById('itemPalette');
        const toggleDayNightButton = document.getElementById('toggleDayNightButton');
        const saveEcosystemButton = document.getElementById('saveEcosystemButton');
        const loadEcosystemButton = document.getElementById('loadEcosystemButton');
        const clearEcosystemButton = document.getElementById('clearEcosystemButton');

        const CANVAS_WIDTH = 600; 
        const CANVAS_HEIGHT = 450;
        canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
        waterSurfaceCanvas.width = CANVAS_WIDTH; waterSurfaceCanvas.height = CANVAS_HEIGHT;


        let ecosystemItems = []; 
        let selectedPaletteItem = null;
        let currentEcosystemType = 'aquarium';
        let isDay = true;
        let animationFrameId = null;
        let gameTick = 0;

        let sounds = {};
        let ambientLoop = null;
        let ambientSynth = null; // For more complex ambient sounds

        function setCanvasSize() { // Defined function
            // For this prototype, canvas size is fixed. If it were dynamic:
            // const parent = canvas.parentElement;
            // canvas.width = parent.clientWidth - 20; // Example padding
            // canvas.height = parent.clientHeight - 20;
            // waterSurfaceCanvas.width = canvas.width;
            // waterSurfaceCanvas.height = canvas.height;
            // drawEcosystem(); // Redraw if size changes
        }


        async function setupAudio() {
            await Tone.start();
            console.log("Audio Context Started");
            startAudioOverlay.classList.add('hidden');

            sounds.placeItem = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 2000, resonance: 0.8, volume: -18 }).toDestination();
            sounds.bubblePop = new Tone.NoiseSynth({ noise: {type: 'white'}, envelope: {attack:0.001, decay:0.02, sustain:0}, volume: -28}).toDestination();
            sounds.tapGlass = new Tone.MembraneSynth({pitchDecay: 0.01, octaves:3, envelope:{attack:0.001, decay:0.05, sustain:0}, volume: -22}).toDestination();
            
            // More complex ambient synth
            ambientSynth = new Tone.PolySynth(Tone.FMSynth, {
                harmonicity: 1.5,
                modulationIndex: 3,
                envelope: { attack: 2, decay: 1, sustain: 0.8, release: 3 },
                modulationEnvelope: { attack: 1, decay: 0.5, sustain: 0.5, release: 2 },
                volume: -35 // Very subtle
            }).toDestination();
            const reverb = new Tone.Reverb(2.5).toDestination(); // Soft reverb
            ambientSynth.connect(reverb);

            updateAmbientSound(); 
        }
        startAudioButton.addEventListener('click', setupAudio);

        function updateAmbientSound() {
            if (ambientLoop) {
                ambientLoop.stop(0);
                ambientLoop.dispose();
                ambientLoop = null;
            }
            if (Tone.context && Tone.context.state === 'running' && ambientSynth) {
                if (currentEcosystemType === 'aquarium') {
                    const notes = ["C2", "F2", "G2", "A#2"];
                    let noteIdx = 0;
                    ambientLoop = new Tone.Loop(time => {
                        if (Math.random() < 0.3) { // Play sparsely
                            ambientSynth.triggerAttackRelease(notes[noteIdx % notes.length] , "8m", time); // Long notes
                            noteIdx++;
                        }
                    }, "12s").start(Math.random() * 5); // Start at a random offset
                } else { // Terrarium
                    const cricketChirp = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.005, decay: 0.02, sustain: 0.005, release: 0.01 },
                        volume: -33
                    }).toDestination();
                    ambientLoop = new Tone.Loop(time => {
                        if (isDay && Math.random() < 0.4) {
                            cricketChirp.triggerAttackRelease(Tone.Frequency("C6").transpose(Math.random()*6-3), "64n", time + Math.random()*0.2);
                        }
                    }, "1.5s").start(Math.random());
                }
            }
        }

        const paletteData = {
            aquarium: [
                { name: "Sand", type: "substrate", emoji: "ðŸ–ï¸", color: "#E0C9A6", hasGravity: true }, // Lighter sand
                { name: "Gravel", type: "substrate", emoji: "ðŸª¨", color: "#B0B0B0", hasGravity: true }, // Lighter gravel
                { name: "Smooth Stone", type: "hardscape", emoji: "âšª", size: 30, shape: 'rock1', color: "#C0C0C0", hasGravity: true },
                { name: "Coral Branch", type: "hardscape", emoji: "ðŸª¸", size: 45, shape: 'coral_branch', color: '#FFB6C1', hasGravity: true }, // Light Pink Coral
                { name: "Driftwood Arch", type: "hardscape", emoji: "ðŸªµ", size: 80, shape: 'driftwood_arch', color: "#A0522D", hasGravity: true },
                { name: "Anubias Nana", type: "plant", emoji: "ðŸŒ¿", size: 35, growthRate: 0.008, color: '#3B5323' }, // Darker, natural green
                { name: "Vallisneria", type: "plant", emoji: "ðŸŒ±", size: 60, growthRate: 0.012, color: '#556B2F', isTall: true }, // Tall, grassy
                { name: "Water Lily Pad", type: "plant", emoji: "ðŸŒ¸", size: 40, growthRate: 0.01, color: '#90EE90', isFloating: true, fixedY: CANVAS_HEIGHT * 0.15 }, // Floats near surface
                { name: "Moss Ball", type: "plant", emoji: "ðŸŸ¢", size: 25, growthRate: 0.005, color: '#224B0C', hasGravity: true }, // Can rest on bottom
                { name: "Neon Tetra", type: "fauna", emoji: "ðŸ ", size: 15, speed: 0.6, behavior: 'swim_school' },
                { name: "Mystery Snail", type: "fauna", emoji: "ðŸŒ", size: 12, speed: 0.08, behavior: 'crawl_aq' },
                { name: "Cherry Shrimp", type: "fauna", emoji: "ðŸ¦", size: 10, speed: 0.25, behavior: 'scuttle_aq' },
                { name: "Air Stone Bubbler", type: "special", emoji: "ðŸ«§", size: 20, behavior: 'bubble', hasGravity: true },
            ],
            terrarium: [
                { name: "Dark Soil", type: "substrate", emoji: "ðŸŸ«", color: "#5D4037", hasGravity: true },
                { name: "Fine Pebbles", type: "substrate", emoji: "âš«", color: "#A9A9A9", hasGravity: true },
                { name: "Slate Rock", type: "hardscape", emoji: "âž–", size: 55, shape: 'rock_flat', color: "#6C7A89", hasGravity: true },
                { name: "Mossy Branch", type: "hardscape", emoji: "ðŸŒ¿", size: 70, shape: 'log_mossy', color: "#795548", hasGravity: true },
                { name: "Mini Fern", type: "plant", emoji: "ðŸŒ±", size: 30, growthRate: 0.007, color: '#2E8B57' },
                { name: "Ground Moss", type: "plant", emoji: "ðŸŸ©", size: 40, growthRate: 0.005, color: '#556B2F', isGroundCover: true }, // Spreads slightly
                { name: "Echeveria", type: "plant", emoji: "ðŸŒ¸", size: 28, growthRate: 0.004, color: '#B2BEB5', onHardscape: false }, // Rosette succulent
                { name: "Tillandsia", type: "plant", emoji: "ðŸ’¨", size: 22, growthRate: 0.003, color: '#A7B4A0', onHardscape: true },
                { name: "Amethyst Geode", type: "special", emoji: "ðŸ’Ž", size: 25, behavior: 'glow', color: '#9B59B6', hasGravity: true },
                { name: "Ladybug", type: "fauna", emoji: "ðŸž", size: 8, speed: 0.25, behavior: 'crawl_tr_plant' }, // Prefers plants
                { name: "Earthworm", type: "fauna", emoji: "ðŸª±", size: 10, speed: 0.07, behavior: 'crawl_tr_soil' }, // Stays in soil
                { name: "Fly Agaric", type: "plant", emoji: "ðŸ„", size: 18, growthRate: 0.015, behavior: 'sprout_shroom', color: '#D24D57' },
            ]
        };

        function populatePalette() {
            itemPaletteDiv.innerHTML = '';
            paletteData[currentEcosystemType].forEach(item => {
                const button = document.createElement('div');
                button.classList.add('palette-item');
                
                const itemDisplay = document.createElement('div');
                itemDisplay.classList.add('item-emoji');
                itemDisplay.textContent = item.emoji;
                button.appendChild(itemDisplay);

                const itemName = document.createElement('div');
                itemName.classList.add('item-name');
                itemName.textContent = item.name;
                button.appendChild(itemName);

                button.addEventListener('click', () => {
                    selectedPaletteItem = item;
                    document.querySelectorAll('.palette-item').forEach(p => p.classList.remove('selected'));
                    button.classList.add('selected');
                });
                itemPaletteDiv.appendChild(button);
            });
        }

        function addItemToEcosystem(x, y) {
            if (!selectedPaletteItem) return;

            const newItem = {
                ...selectedPaletteItem, 
                id: `item-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                x, y,
                currentSize: selectedPaletteItem.size || 20, 
                angle: (selectedPaletteItem.type === 'fauna' || selectedPaletteItem.shape === 'driftwood_arch') ? 0 : Math.random() * Math.PI * 0.2 - 0.1, // Less random angle for most
                targetX: x, targetY: y, 
                animationFrame: 0,
                growth: 0, 
                lastActionTime: gameTick,
                vy: 0, // For gravity
                isFalling: !!selectedPaletteItem.hasGravity, // Start falling if has gravity
                isResting: false,
                data: {} 
            };

            if (newItem.type === 'substrate') { 
                const substrateHeight = CANVAS_HEIGHT * 0.15;
                newItem.y = CANVAS_HEIGHT - substrateHeight / 2; // Center of substrate layer
                newItem.x = x; // Allow placing along x-axis
                newItem.isFalling = false; // Substrate doesn't fall further once placed
                newItem.isResting = true;
            } else if (newItem.type === 'plant' && newItem.onHardscape) {
                let placedOnObject = false;
                for (const existingItem of ecosystemItems.filter(it => it.type === 'hardscape').sort((a,b) => a.y - b.y)) { // Check lower items first
                    if (Math.abs(x - existingItem.x) < existingItem.currentSize / 2 && y > existingItem.y - existingItem.currentSize/2 && y < existingItem.y + existingItem.currentSize/4) { // Check if click is on top part
                        newItem.x = x; // Place where clicked on the hardscape
                        newItem.y = existingItem.y - existingItem.currentSize / 2 - newItem.currentSize * 0.3; // Attach to top surface
                        newItem.isFalling = false; newItem.isResting = true;
                        placedOnObject = true;
                        break;
                    }
                }
                if (!placedOnObject) {
                    alert("This plant prefers to be placed on rocks or wood!"); return;
                }
            } else if (newItem.type === 'plant' && !newItem.isFloating) { 
                 newItem.isFalling = true; // Plants will fall until they hit substrate/hardscape
            } else if (newItem.isFloating) {
                newItem.y = newItem.fixedY || CANVAS_HEIGHT * 0.15; // Place floating plants at their fixed Y
                newItem.isFalling = false; newItem.isResting = true;
            }


            ecosystemItems.push(newItem);
            selectedPaletteItem = null; 
            document.querySelectorAll('.palette-item').forEach(p => p.classList.remove('selected'));
            
            if (Tone.context && Tone.context.state === 'running' && sounds.placeItem) {
                sounds.placeItem.triggerAttackRelease(newItem.type === 'substrate' ? "C3" : "C4", "8n", Tone.now());
            }
        }
        
        function getSubstrateOrHardscapeLevel(x, ignoreItemId = null) {
            let highestSolidY = CANVAS_HEIGHT;
            ecosystemItems.forEach(item => {
                if (item.id === ignoreItemId) return;
                if (item.type === 'substrate' || (item.type === 'hardscape' && item.isResting)) {
                    // Check if x is within the horizontal bounds of this item
                    if (Math.abs(item.x - x) < (item.currentSize / 2) || item.type === 'substrate') { // Substrate is full width
                         const itemTopY = item.y - item.currentSize / 2;
                         if (itemTopY < highestSolidY) {
                            highestSolidY = itemTopY;
                         }
                    }
                }
            });
            return highestSolidY;
        }


        function drawEcosystem() {
            // Background
            const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            if (currentEcosystemType === 'aquarium') {
                grad.addColorStop(0, isDay ? '#a0d2eb' : '#003973'); // Light blue / Dark blue sky
                grad.addColorStop(0.1, isDay ? '#87CEEB' : '#005090'); // Main water color
                grad.addColorStop(0.8, isDay ? '#70b8d8' : '#003060'); // Deeper water
                grad.addColorStop(1, isDay ? '#50a0c0' : '#002040');   // Deepest
            } else { // Terrarium
                grad.addColorStop(0, isDay ? '#c1e1c1' : '#203A20'); // Pale green / Dark forest green sky
                grad.addColorStop(0.7, isDay ? '#d4f0c1' : '#2A4A2A'); // Ground area
                grad.addColorStop(1, isDay ? '#b0d0a0' : '#1A3A1A');   // Deeper ground
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ecosystemItems.sort((a, b) => (a.type === 'substrate' ? -1 : b.type === 'substrate' ? 1 : (a.y + a.currentSize/2) - (b.y + b.currentSize/2) )); // Draw substrates first, then by y-depth

            ecosystemItems.forEach(item => {
                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.rotate(item.angle || 0);
                
                const displaySize = item.currentSize * (1 + item.growth * 0.5); 
                ctx.fillStyle = item.color || '#ccc';
                ctx.strokeStyle = darkenColor(item.color || '#ccc', 25); // Darker outline
                ctx.lineWidth = 1.5;

                if (item.type === 'substrate') {
                    ctx.fillStyle = item.color;
                    // Draw as a strip across the bottom, but respect individual item's y for layering potential
                    const substrateVisualHeight = CANVAS_HEIGHT * 0.15; // How thick it looks
                    ctx.fillRect(-CANVAS_WIDTH, -substrateVisualHeight / 2, CANVAS_WIDTH * 2, substrateVisualHeight);
                } else if (item.type === 'plant') {
                    const stemHeight = displaySize * (item.isTall ? 0.85 : 0.6);
                    const topSize = displaySize * (item.isTall ? 0.3 : 0.5);
                    const stemWidth = Math.max(2, displaySize * 0.08);
                    ctx.fillStyle = darkenColor(item.color, 30); 
                    ctx.fillRect(-stemWidth/2, 0, stemWidth, -stemHeight); 
                    
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    if (item.isFloating) { // Lily pad style
                        ctx.ellipse(0, 0, topSize * 1.2, topSize * 0.8, 0, 0, Math.PI * 2);
                    } else {
                        ctx.ellipse(0, -stemHeight - topSize/2, topSize/1.2, topSize, 0, 0, Math.PI * 2); 
                    }
                    ctx.fill();
                    if (item.behavior === 'sprout_shroom' && item.data.childShrooms) { 
                        item.data.childShrooms.forEach(child => {
                            ctx.save();
                            ctx.translate(child.dx, child.dy);
                            ctx.fillStyle = darkenColor(item.color, 15);
                            ctx.beginPath();
                            ctx.arc(0, -child.size*0.2, child.size*0.3, Math.PI, 0); 
                            ctx.fill();
                            ctx.fillRect(-child.size*0.1, -child.size*0.2, child.size*0.2, child.size*0.2); 
                            ctx.restore();
                        });
                    }

                } else if (item.type === 'hardscape' || item.type === 'special') {
                    ctx.font = `${displaySize}px Arial`; // Using emoji as primary visual
                    if (item.emoji) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        if (item.behavior === 'glow' && !isDay && gameTick % 40 < 20) { 
                            ctx.shadowColor = item.color || '#AFEEEE';
                            ctx.shadowBlur = displaySize / 1.5;
                        }
                        ctx.fillText(item.emoji, 0, 0);
                        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    } else { 
                        ctx.fillStyle = item.color || '#888';
                        ctx.beginPath();
                        // Add more distinct shapes later if needed
                        ctx.fillRect(-displaySize / 2, -displaySize / 2, displaySize, displaySize);
                        ctx.fill();
                    }
                } else if (item.type === 'fauna') {
                    ctx.font = `${displaySize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.emoji, 0, 0);
                }

                if (item.behavior === 'bubble' && item.data.bubbles) {
                    item.data.bubbles.forEach(bubble => {
                        ctx.beginPath();
                        ctx.arc(bubble.xOffset, bubble.yOffset, bubble.radius, 0, Math.PI * 2);
                        ctx.fillStyle = isDay ? 'rgba(200, 230, 255, 0.75)' : 'rgba(220, 240, 255, 0.65)';
                        ctx.fill();
                        ctx.strokeStyle = isDay ? 'rgba(220, 240, 255, 0.5)' : 'rgba(240, 250, 255, 0.4)';
                        ctx.stroke();
                    });
                }
                ctx.restore();
            });

            if (!isDay) {
                ctx.fillStyle = currentEcosystemType === 'aquarium' ? "rgba(0, 20, 80, 0.35)" : "rgba(10, 30, 10, 0.35)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
            drawWaterSurface();
        }
        
        function darkenColor(hex, percent) {
            if (!hex) return '#000000'; // Default if color is undefined
            hex = hex.replace(/^\s*#|\s*$/g, '');
            if(hex.length == 3) hex = hex.replace(/(.)/g, '$1$1');
            
            let r = parseInt(hex.substr(0, 2), 16),
                g = parseInt(hex.substr(2, 2), 16),
                b = parseInt(hex.substr(4, 2), 16);
            
            r = Math.max(0, Math.floor(r * (100 - percent) / 100));
            g = Math.max(0, Math.floor(g * (100 - percent) / 100));
            b = Math.max(0, Math.floor(b * (100 - percent) / 100));

            return "#" + (r < 16 ? "0" : "") + r.toString(16) +
                         (g < 16 ? "0" : "") + g.toString(16) +
                         (b < 16 ? "0" : "") + b.toString(16);
        }

        function drawWaterSurface() {
            if (currentEcosystemType !== 'aquarium') {
                waterCtx.clearRect(0,0,waterSurfaceCanvas.width, waterSurfaceCanvas.height);
                return;
            }
            waterCtx.clearRect(0,0,waterSurfaceCanvas.width, waterSurfaceCanvas.height);
            const waterLevel = CANVAS_HEIGHT * 0.12; // Slightly lower surface
            waterCtx.fillStyle = isDay ? 'rgba(135, 206, 250, 0.25)' : 'rgba(70, 130, 180, 0.3)'; 
            
            waterCtx.beginPath();
            waterCtx.moveTo(0, waterLevel);
            for (let x = 0; x < CANVAS_WIDTH; x+=2) { // Draw fewer points for smoother wave
                const yOffset = Math.sin(x * 0.04 + gameTick * 0.025) * 2.5 + Math.sin(x*0.08 + gameTick*0.04)*1.2;
                waterCtx.lineTo(x, waterLevel + yOffset);
            }
            waterCtx.lineTo(CANVAS_WIDTH, waterLevel);
            waterCtx.lineTo(CANVAS_WIDTH, 0);
            waterCtx.lineTo(0,0);
            waterCtx.closePath();
            waterCtx.fill();
        }


        function updateEcosystem() {
            gameTick++;
            ecosystemItems.forEach(item => {
                item.animationFrame = (item.animationFrame + 1) % 120; // Longer cycle for some animations

                // --- Gravity ---
                if (item.isFalling) {
                    item.vy += 0.15; // Gravity acceleration
                    item.y += item.vy;
                    
                    const groundY = getSubstrateOrHardscapeLevel(item.x, item.id);
                    const itemBottom = item.y + item.currentSize / 2;

                    if (itemBottom >= groundY) {
                        item.y = groundY - item.currentSize / 2;
                        item.isFalling = false;
                        item.isResting = true;
                        item.vy = 0;
                        // If it's a plant, "root" it by slightly adjusting angle
                        if(item.type === 'plant' && !item.onHardscape && !item.isFloating) item.angle = (Math.random()-0.5) * 0.05; 
                    }
                    // Prevent falling through bottom of canvas
                    if (item.y + item.currentSize / 2 > CANVAS_HEIGHT) {
                        item.y = CANVAS_HEIGHT - item.currentSize / 2;
                        item.isFalling = false;
                        item.isResting = true;
                        item.vy = 0;
                    }
                }


                if (item.type === 'plant' && item.growth < 1) {
                    item.growth += (item.growthRate || 0.01) * 0.05; // Slower growth
                    item.growth = Math.min(1, item.growth);
                }
                if (item.behavior === 'sprout_shroom' && item.growth >= 0.5 && !item.data.childShrooms) {
                    item.data.childShrooms = [];
                    const numChildren = Math.floor(Math.random() * 2) + 1; // Fewer, larger child shrooms
                    for(let i=0; i<numChildren; i++) {
                        item.data.childShrooms.push({
                            dx: (Math.random() - 0.5) * item.currentSize * 0.6,
                            dy: (Math.random() - 0.5) * item.currentSize * 0.1,
                            size: item.currentSize * (0.4 + Math.random()*0.25)
                        });
                    }
                }

                if (item.type === 'fauna') {
                    const speed = item.speed || 0.5;
                    if (gameTick % (60 + Math.floor(Math.random()*60)) === 0 || Math.hypot(item.x - item.targetX, item.y - item.targetY) < 10) {
                        item.targetX = item.x + (Math.random() - 0.5) * 150;
                        item.targetY = item.y + (Math.random() - 0.5) * (currentEcosystemType === 'aquarium' ? 100 : 40); 
                        
                        const faunaSize = item.currentSize / 2;
                        item.targetX = Math.max(faunaSize, Math.min(item.targetX, CANVAS_WIDTH - faunaSize));
                        let minY = faunaSize;
                        if (currentEcosystemType === 'aquarium') minY = CANVAS_HEIGHT * 0.12 + faunaSize; 
                        const substrateLevel = getSubstrateOrHardscapeLevel(item.x) - faunaSize;
                        item.targetY = Math.max(minY, Math.min(item.targetY, substrateLevel));
                    }
                    const dx = item.targetX - item.x;
                    const dy = item.targetY - item.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 1) {
                        item.x += (dx / dist) * speed * (isDay ? 1 : 0.7); // Slower at night
                        item.y += (dy / dist) * speed * (isDay ? 1 : 0.7);
                    }
                    item.angle = (currentEcosystemType === 'aquarium' && dx < 0) ? Math.PI + Math.atan2(dy, dx) : Math.atan2(dy, dx); // Fish flip
                }

                if (item.behavior === 'bubble') {
                    if (!item.data.bubbles) item.data.bubbles = [];
                    if (item.animationFrame % (isDay? 10:15) === 0 && item.data.bubbles.length < (isDay?12:8)) { 
                        item.data.bubbles.push({ xOffset: (Math.random()-0.5)*item.currentSize*0.15, yOffset: -item.currentSize/2, radius: Math.random()*2.5+1.5, age:0 });
                    }
                    item.data.bubbles = item.data.bubbles.filter(b => {
                        b.yOffset -= (0.7 + Math.random()*0.3); 
                        b.xOffset += (Math.random()-0.5)*0.4; 
                        b.radius *= 1.003; 
                        b.age++;
                        if (b.yOffset < -CANVAS_HEIGHT * 0.85) { 
                             if (Tone.context && Tone.context.state === 'running' && sounds.bubblePop) sounds.bubblePop.triggerAttackRelease("64n");
                            return false;
                        }
                        return true;
                    });
                }
            });
        }

        function gameLoop() {
            updateEcosystem();
            drawEcosystem();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        ecosystemTypeSelect.addEventListener('change', (e) => {
            currentEcosystemType = e.target.value;
            clearEcosystemButton.click(); 
            populatePalette();
            updateAmbientSound();
            drawEcosystem(); 
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let tappedCreature = false;
            ecosystemItems.forEach(item => {
                if (item.type === 'fauna') {
                    if (Math.hypot(x - item.x, y - item.y) < item.currentSize * 1.5) { // Increased tap radius
                        item.targetX = item.x + (Math.random() - 0.5) * 120; // Dart further
                        item.targetY = item.y + (Math.random() - 0.5) * 120;
                        if (Tone.context && Tone.context.state === 'running' && sounds.tapGlass) sounds.tapGlass.triggerAttackRelease("C3", "16n");
                        tappedCreature = true;
                    }
                }
            });
            if (tappedCreature) return;

            if (selectedPaletteItem) {
                addItemToEcosystem(x, y);
            }
        });

        toggleDayNightButton.addEventListener('click', () => {
            isDay = !isDay;
            updateAmbientSound(); // May change ambient sound based on day/night
        });

        clearEcosystemButton.addEventListener('click', () => {
            ecosystemItems = [];
        });

        saveEcosystemButton.addEventListener('click', () => {
            const saveData = {
                type: currentEcosystemType,
                items: ecosystemItems,
                isDay: isDay
            };
            localStorage.setItem(`pocketEcosystem_${currentEcosystemType}`, JSON.stringify(saveData));
            alert(`${currentEcosystemType.charAt(0).toUpperCase() + currentEcosystemType.slice(1)} saved!`);
        });

        loadEcosystemButton.addEventListener('click', () => {
            const savedData = localStorage.getItem(`pocketEcosystem_${currentEcosystemType}`);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                if (parsedData.type === currentEcosystemType) {
                    ecosystemItems = parsedData.items || [];
                    isDay = parsedData.isDay !== undefined ? parsedData.isDay : true;
                    updateAmbientSound(); // Update sound to match loaded state
                    alert(`${currentEcosystemType.charAt(0).toUpperCase() + currentEcosystemType.slice(1)} loaded!`);
                } else {
                    alert(`No saved ${currentEcosystemType} found. Current save is for a ${parsedData.type}.`);
                }
            } else {
                alert(`No saved ${currentEcosystemType} found.`);
            }
        });

        window.addEventListener('load', () => {
            setCanvasSize(); 
            populatePalette();
        });
        window.addEventListener('resize', () => {
            setCanvasSize(); 
        });
        
        startAudioButton.addEventListener('click', () => {
            if (!animationFrameId) { 
                gameLoop();
            }
        });

    </script>
</body>
</html>
