<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Abyssal Angler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000510; /* Very dark deep blue */
            color: #b0c4de; /* Light steel blue */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            touch-action: manipulation; /* Prevents zoom, etc. */
        }
        #gameContainer {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            max-height: 600px;
            position: relative;
            box-shadow: 0 0 25px rgba(0, 120, 255, 0.4);
            border-radius: 10px;
            overflow: hidden;
            background: #000510;
        }
        canvas {
            display: block;
            /* Base background is now slightly lighter for minimal ambient visibility */
            background: linear-gradient(to bottom, #000814, #001224, #002244); 
            border-radius: 10px;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            font-size: 0.9rem;
            z-index: 10;
            pointer-events: none; 
        }
        .ui-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .ui-element {
            background-color: rgba(0, 20, 40, 0.75);
            padding: 6px 10px;
            border-radius: 5px;
            border: 1px solid rgba(0, 100, 200, 0.5);
            box-shadow: 0 0 8px rgba(0, 150, 255, 0.3);
            color: #e0f0ff;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 5, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            padding: 20px;
            border-radius: 10px;
            pointer-events: auto; 
        }
        .screen h1 {
            font-size: 2.2em;
            margin-bottom: 20px;
            color: #66ccff; 
            text-shadow: 0 0 10px #66ccff;
        }
        .screen p {
            font-size: 1.1em;
            margin-bottom: 15px;
            max-width: 90%;
            line-height: 1.5;
        }
        .button {
            background: linear-gradient(145deg, #0077ff, #0055cc);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 0 5px rgba(0,150,255,0.5) inset;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .button:hover {
            background: linear-gradient(145deg, #0088cc, #0066dd); 
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4), 0 0 10px rgba(0,180,255,0.7) inset;
            transform: translateY(-1px);
        }
        .button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 3px rgba(0,120,200,0.4) inset;
        }
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 750px;
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
        }
        .upgrade-item {
            background-color: rgba(10, 30, 60, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3399ff;
            text-align: left;
        }
        .upgrade-item h3 { color: #66ccff; margin-bottom: 5px; }
        .upgrade-item p { font-size: 0.9em; margin-bottom: 8px; }
        .upgrade-item .cost { font-weight: bold; color: #ffdd44; } 
        #messageBox {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #0077ff; color: white; padding: 15px 25px;
            border-radius: 8px; z-index: 1000; opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 119, 255, 0.5);
        }
        #messageBox.show { opacity: 1; transform: translateX(-50%) translateY(-10px); }
        #miniMap {
            width: 100px; height: 100px;
            background-color: rgba(0,10,20,0.8);
            border: 1px solid #3399ff;
            border-radius: 5px;
            position: absolute;
            bottom: 10px; right: 10px;
            z-index: 15;
        }
        .tool-select-button {
            pointer-events: auto; 
            margin-left: 5px;
            font-size: 0.8em;
            padding: 5px 8px;
        }
        .touch-controls-angler {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: none; 
            justify-content: space-between;
            align-items: flex-end;
            z-index: 15;
            pointer-events: none; 
        }
        .touch-joystick-base {
            width: 120px; height: 120px;
            background-color: rgba(0, 50, 100, 0.4);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
        }
        .touch-joystick-stick {
            width: 60px; height: 60px;
            background-color: rgba(0, 100, 200, 0.7);
            border-radius: 50%;
            position: absolute;
            top: 30px; left: 30px;
            border: 2px solid rgba(0, 150, 255, 0.9);
        }
        .touch-action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        .touch-button-angler {
            width: 60px; height: 60px;
            background-color: rgba(0, 119, 255, 0.7);
            border: 2px solid rgba(0, 200, 255, 0.9);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
            user-select: none;
        }
        #helpIconContainer {
            position: absolute;
            top: 10px;
            right: 10px; 
            z-index: 25; 
            pointer-events: auto;
        }
        #helpIcon {
            width: 30px;
            height: 30px;
            background-color: rgba(0, 50, 100, 0.7);
            color: #66ccff;
            border: 1px solid #3399ff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        #helpTooltip {
            display: none;
            position: absolute;
            top: 40px; 
            right: 0;
            width: 250px; 
            background-color: rgba(0, 20, 50, 0.95); 
            color: #e0f0ff;
            border: 1px solid #3399ff;
            border-radius: 5px;
            padding: 12px; 
            font-size: 0.9em; 
            line-height: 1.5;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        #helpTooltip h4 {
            color: #66ccff;
            margin-top: 0;
            margin-bottom: 10px; 
            font-size: 1.05em; 
            border-bottom: 1px solid #3399ff66;
            padding-bottom: 5px;
        }
        #helpTooltip ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #helpTooltip li {
            margin-bottom: 5px; 
        }
         #helpTooltip strong {
            color: #87CEFA; 
        }


        @media (max-width: 768px) { 
            .ui-overlay { font-size: 0.8rem; padding: 8px 10px; }
            .ui-element { padding: 5px 8px; }
            .screen h1 { font-size: 1.8em; }
            .screen p { font-size: 0.95em; }
            .button { padding: 10px 20px; font-size: 1em; }
            .touch-controls-angler { display: flex; }
            #gameContainer { max-width: 100%; max-height: 100%; border-radius: 0; }
            canvas { border-radius: 0; }
            #miniMap { width: 80px; height: 80px; bottom: 70px; }
            #helpIconContainer { top: 50px; right: 10px; }
            #helpTooltip { width: 200px; font-size: 0.8em;}
        }
        @media (hover: none) and (pointer: coarse) { 
            .touch-controls-angler { display: flex; }
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <div class="ui-column">
                <div class="ui-element">Depth: <span id="depthDisplay">0</span>m</div>
                <div class="ui-element">Max Depth: <span id="maxDepthDisplay">0</span>m</div>
                <div class="ui-element">Energy: <span id="energyDisplay">100</span>%</div>
                <div class="ui-element">Hull: <span id="hullDisplay">100</span>%</div>
            </div>
            <div class="ui-column">
                <div class="ui-element">RP: <span id="rpDisplay">0</span></div>
                <div class="ui-element">Shards: <span id="shardsDisplay">0</span></div>
                <div class="ui-element">Cargo: <span id="cargoDisplay">0/10</span></div>
                <div class="ui-element">Tool: <span id="toolDisplay">Hook</span>
                    <button id="switchToolButton" class="button tool-select-button">Sonar</button>
                </div>
                 </div>
        </div>
        <div id="miniMap"></div>

        <div id="helpIconContainer">
            <div id="helpIcon">?</div>
            <div id="helpTooltip">
                <h4>How to Play: Abyssal Angler</h4>
                <p><strong>Goal:</strong> Explore the depths, collect resources, and upgrade your sub to dive deeper!</p>
                <ul>
                    <li><strong>Move Sub:</strong> WASD / Arrow Keys</li>
                    <li><strong>Aim Spotlight/Tool:</strong> Use your <strong>Mouse</strong>. Your sub's light follows the cursor. Keep it pointed where you want to see!</li>
                    <li><strong>Use Selected Tool:</strong> Left Click / Spacebar</li>
                    <li><strong>Switch Tool (Hook/Sonar):</strong> Q Key</li>
                </ul>
                <hr style="border-color: #3399ff66; margin: 8px 0;">
                <h4>Collecting Resources:</h4>
                <ul>
                    <li><strong>Glowing Flora (Plants):</strong> Drive near them for <strong>Research Points (RP)</strong>.</li>
                    <li><strong>Specimens (Creatures):</strong> Use <strong>Grappling Hook</strong> for <strong>RP</strong>. Fills cargo.</li>
                    <li><strong>Treasure Chests:</strong> Use <strong>Grappling Hook</strong> for <strong>Atlantium Shards</strong> (currency).</li>
                </ul>
                 <hr style="border-color: #3399ff66; margin: 8px 0;">
                <h4>Touch Controls:</h4>
                <ul>
                    <li><strong>Move:</strong> On-screen Joystick (Left)</li>
                    <li><strong>Aim Spotlight:</strong> Tap anywhere on the game screen.</li>
                    <li><strong>Use Tool:</strong> HOOK/PING Button (Right)</li>
                    <li><strong>Switch Tool:</strong> SWAP Button (Right)</li>
                </ul>
                <p style="font-size:0.9em; margin-top:8px;"><em>Aggressive creatures will attack! Avoid them or use future upgrades (not yet implemented) to deter them.</em></p>
            </div>
        </div>


        <div id="startScreen" class="screen">
            <h1>Abyssal Angler</h1>
            <p>Descend into the mysterious depths. Collect resources, research alien life, and upgrade your submersible to explore the unknown.</p>
            <p class="text-sm">Controls: WASD/Arrows to move. Mouse to aim spotlight/tools. Left Click/Space to use tool. Q to switch tool.<br/>Touch: Joystick to move. Tap screen to aim. Buttons for tools.</p>
            <button id="startGameButton" class="button">Begin Dive</button>
        </div>

        <div id="diveSummaryScreen" class="screen" style="display: none;">
            <h1>Dive Summary</h1>
            <p>Depth Reached: <span id="summaryDepth">0</span>m</p>
            <p>Research Points Gained: <span id="summaryRP">0</span></p>
            <p>Atlantium Shards Found: <span id="summaryShards">0</span></p>
            <p>Specimens Collected: <span id="summarySpecimens">0</span></p>
            <button id="returnToBaseButton" class="button">Return to Base</button>
        </div>

        <div id="gameOverScreen" class="screen" style="display: none;">
            <h1>Sub Damaged!</h1>
            <p>Your submersible was critically damaged. Resources from this dive are lost.</p>
            <p>Final Depth: <span id="finalDepthDisplay">0</span>m</p>
            <button id="goToBaseButtonGameOver" class="button">Return to Base</button>
        </div>

        <div id="upgradeScreen" class="screen" style="display: none;">
            <h1>Submersible Bay</h1>
            <div class="flex justify-around w-full max-w-lg mb-3">
                <div class="ui-element">RP: <span id="upgradeRPDisplay">0</span></div>
                <div class="ui-element">Shards: <span id="upgradeShardsDisplay">0</span></div>
            </div>
            <div id="upgradeGrid" class="upgrade-grid"></div>
            <button id="exitUpgradeScreenButton" class="button">Exit Bay (Start New Dive)</button>
        </div>

        <div id="messageBox">Sample Message</div>

        <div class="touch-controls-angler">
            <div id="touchJoystickBase" class="touch-joystick-base">
                <div id="touchJoystickStick" class="touch-joystick-stick"></div>
            </div>
            <div class="touch-action-buttons">
                <button id="touchToolActionButton" class="touch-button-angler">HOOK</button>
                <button id="touchSwitchToolButton" class="touch-button-angler">SWAP</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports REMOVED

        // --- Game Configuration ---
        const FPS = 60;
        const SUB_SIZE = 25;
        const SUB_ACCEL = 0.08;
        const SUB_MAX_SPEED = 2.5;
        const FRICTION = 0.96;
        const CAMERA_LERP_FACTOR = 0.08;
        const AMBIENT_LIGHT_LEVEL = 0.05; 

        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // UI Displays
        const depthDisplay = document.getElementById('depthDisplay');
        const maxDepthDisplay = document.getElementById('maxDepthDisplay');
        const energyDisplay = document.getElementById('energyDisplay');
        const hullDisplay = document.getElementById('hullDisplay');
        const rpDisplay = document.getElementById('rpDisplay');
        const shardsDisplay = document.getElementById('shardsDisplay');
        const cargoDisplay = document.getElementById('cargoDisplay');
        const toolDisplay = document.getElementById('toolDisplay');
        const switchToolButton = document.getElementById('switchToolButton');
        // const userIdDisplay = document.getElementById('userIdDisplay'); // REMOVED
        const miniMapElement = document.getElementById('miniMap'); 

        // Screens
        const startScreen = document.getElementById('startScreen');
        const diveSummaryScreen = document.getElementById('diveSummaryScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const upgradeScreen = document.getElementById('upgradeScreen');
        // Screen Buttons & Info
        const startGameButton = document.getElementById('startGameButton');
        const returnToBaseButton = document.getElementById('returnToBaseButton');
        const goToBaseButtonGameOver = document.getElementById('goToBaseButtonGameOver');
        const exitUpgradeScreenButton = document.getElementById('exitUpgradeScreenButton');
        const summaryDepth = document.getElementById('summaryDepth');
        const summaryRP = document.getElementById('summaryRP');
        const summaryShards = document.getElementById('summaryShards');
        const summarySpecimens = document.getElementById('summarySpecimens');
        const finalDepthDisplay = document.getElementById('finalDepthDisplay');
        const upgradeRPDisplay = document.getElementById('upgradeRPDisplay');
        const upgradeShardsDisplay = document.getElementById('upgradeShardsDisplay');
        const upgradeGrid = document.getElementById('upgradeGrid');
        const messageBox = document.getElementById('messageBox');
        const helpIcon = document.getElementById('helpIcon');
        const helpTooltip = document.getElementById('helpTooltip');


        // Touch controls
        const touchJoystickBase = document.getElementById('touchJoystickBase');
        const touchJoystickStick = document.getElementById('touchJoystickStick');
        const touchToolActionButton = document.getElementById('touchToolActionButton');
        const touchSwitchToolButton = document.getElementById('touchSwitchToolButton');


        // --- Local Storage Keys ---
        const LOCAL_STORAGE_PREFIX = "abyssalAngler_";
        const MAX_DEPTH_KEY = LOCAL_STORAGE_PREFIX + "maxDepth";
        const PROGRESS_KEY = LOCAL_STORAGE_PREFIX + "progress";
        
        // --- Game State ---
        let sub;
        let collectibles = [];
        let creatures = [];
        let obstacles = [];
        let particles = [];
        let sonarPings = []; 
        let gameState = 'start'; 
        let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, down: false };
        let keys = {};
        let camera = { x: 0, y: 0 };
        let currentDepth = 0;
        let diveStats = { rp: 0, shards: 0, specimens: 0 }; 
        let maxDepth = 0;


        // Submersible Stats (upgradable)
        let subStats = { 
            spotlightRange: 170, 
            spotlightWidth: Math.PI / 2.8, 
            spotlightIntensity: 1.0, 
            enginePower: SUB_ACCEL,
            maxSpeed: SUB_MAX_SPEED,
            hullIntegrity: 100, 
            maxHull: 100,       
            grappleRange: 200,
            grappleSpeed: 5,
            sonarRange: 300,
            sonarEnergyCost: 10,
            toolArmAttachments: [], 
            cargoCapacity: 10,
            currentCargo: 0,
            energyCore: 100,    
            maxEnergy: 100,     
            energyRegenRate: 0.1, 
            researchPoints: 0, 
            atlantiumShards: 0, 
            currentTool: 'hook', 
        };

        const upgradesConfig = [
            { id: 'spotlightRange', name: 'Spotlight Range', baseValue: 170, baseCostRP: 50, baseCostShards: 0, levels: 5, desc: 'Increase light cone distance.', increase: 35 }, 
            { id: 'spotlightWidth', name: 'Spotlight Width', baseValue: Math.PI / 2.8, baseCostRP: 70, baseCostShards: 10, levels: 3, desc: 'Widen light cone.', increase: Math.PI / 10 }, 
            { id: 'enginePower', name: 'Engine Power', baseValue: SUB_ACCEL, baseCostRP: 100, baseCostShards: 20, levels: 5, desc: 'Faster acceleration.', increase: 0.02 },
            { id: 'maxHull', name: 'Hull Integrity', baseValue: 100, baseCostRP: 120, baseCostShards: 30, levels: 5, desc: 'Increase max hull strength.', increase: 25 },
            { id: 'grappleRange', name: 'Grapple Range', baseValue: 200, baseCostRP: 80, baseCostShards: 15, levels: 4, desc: 'Extend grappling hook reach.', increase: 50 },
            { id: 'grappleSpeed', name: 'Grapple Speed', baseValue: 5, baseCostRP: 60, baseCostShards: 10, levels: 3, desc: 'Faster grapple retraction.', increase: 1.5 },
            { id: 'sonarRange', name: 'Sonar Range', baseValue: 300, baseCostRP: 150, baseCostShards: 25, levels: 4, desc: 'Wider sonar pulse radius.', increase: 75 },
            { id: 'cargoCapacity', name: 'Cargo Hold', baseValue: 10, baseCostRP: 75, baseCostShards: 5, levels: 5, desc: 'Carry more items.', increase: 5 },
            { id: 'maxEnergy', name: 'Energy Core', baseValue: 100, baseCostRP: 100, baseCostShards: 20, levels: 5, desc: 'Increase max energy.', increase: 25 },
            { id: 'energyRegenRate', name: 'Energy Regen', baseValue: 0.1, baseCostRP: 200, baseCostShards: 50, levels: 3, desc: 'Faster passive energy regen.', increase: 0.05 },
        ];
        let currentUpgradeLevels = {};


        // --- Sound Engine (Tone.js) ---
        const mainSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination();
        mainSynth.volume.value = -12;
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 } }).toDestination();
        noiseSynth.volume.value = -20;
        const ambientWind = new Tone.NoiseSynth({
            noise: { type: "brown", playbackRate: 0.2 },
            envelope: { attack: 2, decay: 1, sustain: 1, release: 2 }
        }).toDestination();
        ambientWind.volume.value = -35; 

        let thrusterSound; 

        async function setupSounds() {
            thrusterSound = new Tone.NoiseSynth({
                noise: {type: "white"},
                envelope: {attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.05},
                volume: -25
            }).toDestination();
            console.log("Sound setup complete (thruster synth initialized).");
        }

        function playSound(type, note = 'C4', duration = '8n') {
            if (Tone.context.state !== 'running') {
                console.warn("AudioContext not running when trying to play sound:", type);
                Tone.start().catch(err => console.error("Deferred Tone.start() failed:", err));
                return; 
            }
            try {
                switch (type) {
                    case 'pickup_flora': mainSynth.triggerAttackRelease('A4', '16n'); break;
                    case 'pickup_treasure': mainSynth.triggerAttackRelease('E5', '8n'); break;
                    case 'pickup_specimen': mainSynth.triggerAttackRelease('C#5', '8n'); break;
                    case 'grapple_fire': noiseSynth.triggerAttackRelease('16n'); mainSynth.triggerAttackRelease('G3', '16n'); break;
                    case 'grapple_hit': mainSynth.triggerAttackRelease('D3', '16n'); break;
                    case 'sonar_ping':
                        const sonarSynth = new Tone.Synth({ oscillator: {type: "triangle"}, envelope: {attack:0.01, decay:0.5, sustain:0.1, release:0.5}, volume: -10}).toDestination();
                        sonarSynth.triggerAttackRelease('A5', '1n');
                        setTimeout(() => sonarSynth.dispose(), 1000); 
                        break;
                    case 'hull_damage': mainSynth.triggerAttackRelease('C2', '4n'); noiseSynth.triggerAttackRelease('8n'); break;
                    case 'creature_agro': mainSynth.triggerAttackRelease('F#3', '8n'); break;
                    case 'upgrade_purchase': mainSynth.triggerAttackRelease('G5', '8n', Tone.now()); mainSynth.triggerAttackRelease('C6', '8n', Tone.now() + 0.1); break;
                    case 'dive_start': mainSynth.triggerAttackRelease('C4', '2n'); break;
                    case 'game_over_sound': mainSynth.triggerAttackRelease('A2', '1n'); break;
                    case 'thruster_burst': if(thrusterSound) thrusterSound.triggerAttackRelease("32n"); break;
                }
            } catch (err) { console.warn("Tone.js sound error:", err); }
        }


        // --- Game Objects ---
        class Submersible {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = SUB_SIZE / 2;
                this.angle = -Math.PI / 2; 
                this.vel = { x: 0, y: 0 };
                this.accel = { x: 0, y: 0 };
                this.spotlightAngle = -Math.PI / 2;
                this.grapplingHook = { active: false, x: 0, y: 0, targetX: 0, targetY: 0, state: 'idle', attachedTo: null, length: 0 };
                this.lastSonarTime = 0;
            }

            update() {
                this.vel.x += this.accel.x;
                this.vel.y += this.accel.y;
                this.vel.x *= FRICTION;
                this.vel.y *= FRICTION;
                const speed = Math.hypot(this.vel.x, this.vel.y);
                if (speed > subStats.maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * subStats.maxSpeed;
                    this.vel.y = (this.vel.y / speed) * subStats.maxSpeed;
                }
                this.x += this.vel.x;
                this.y += this.vel.y;
                currentDepth = Math.max(0, Math.floor(this.y / 10)); 
                this.spotlightAngle = Math.atan2(mouse.worldY - this.y, mouse.worldX - this.x);
                if (subStats.energyCore < subStats.maxEnergy) {
                    subStats.energyCore += subStats.energyRegenRate / FPS;
                    subStats.energyCore = Math.min(subStats.energyCore, subStats.maxEnergy);
                }
                this.updateGrapple();
            }

            updateGrapple() {
                const hook = this.grapplingHook;
                if (!hook.active) return;

                if (hook.state === 'firing') {
                    const dx = hook.targetX - hook.x;
                    const dy = hook.targetY - hook.y;
                    const distToTarget = Math.hypot(dx, dy);
                    const moveSpeed = subStats.grappleSpeed * 2; 

                    if (distToTarget < moveSpeed || hook.length >= subStats.grappleRange) {
                        if (distToTarget < moveSpeed) { 
                            hook.attachedTo = this.checkGrappleCollision();
                            if (hook.attachedTo) {
                                hook.state = 'attached';
                                playSound('grapple_hit');
                            } else {
                                hook.state = 'retracting'; 
                            }
                        } else { 
                           hook.state = 'retracting';
                        }
                    } else {
                        const angle = Math.atan2(dy, dx);
                        hook.x += Math.cos(angle) * moveSpeed;
                        hook.y += Math.sin(angle) * moveSpeed;
                        hook.length = Math.hypot(hook.x - this.x, hook.y - this.y);
                    }
                } else if (hook.state === 'attached') {
                    if (!hook.attachedTo || hook.attachedTo.collected) { 
                        hook.state = 'retracting';
                        hook.attachedTo = null;
                        return;
                    }
                    
                    const pullTarget = hook.attachedTo.isHeavy ? this : hook.attachedTo; 
                    const anchor = hook.attachedTo.isHeavy ? hook.attachedTo : this;

                    const dx = anchor.x - pullTarget.x;
                    const dy = anchor.y - pullTarget.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist > this.radius + (hook.attachedTo.radius || 5)) { 
                        const angle = Math.atan2(dy, dx);
                        pullTarget.x += Math.cos(angle) * subStats.grappleSpeed * 0.5; 
                        pullTarget.y += Math.sin(angle) * subStats.grappleSpeed * 0.5;
                        if (pullTarget === this) { 
                            this.vel.x += Math.cos(angle) * subStats.grappleSpeed * 0.1;
                            this.vel.y += Math.sin(angle) * subStats.grappleSpeed * 0.1;
                        }
                    } else { 
                         if (pullTarget !== this && typeof pullTarget.collect === 'function') {
                             pullTarget.collect(); 
                         }
                         hook.state = 'retracting'; 
                    }
                    hook.x = hook.attachedTo.x;
                    hook.y = hook.attachedTo.y;

                } else if (hook.state === 'retracting') {
                    const dx = this.x - hook.x;
                    const dy = this.y - hook.y;
                    const distToSub = Math.hypot(dx, dy);
                    if (distToSub < subStats.grappleSpeed * 1.5) {
                        hook.active = false;
                        hook.state = 'idle';
                    } else {
                        const angle = Math.atan2(dy, dx);
                        hook.x += Math.cos(angle) * subStats.grappleSpeed * 1.5; 
                        hook.y += Math.sin(angle) * subStats.grappleSpeed * 1.5;
                    }
                }
                hook.length = Math.hypot(hook.x - this.x, hook.y - this.y);
            }

            checkGrappleCollision() {
                for (let item of collectibles) {
                    if (!item.collected && Math.hypot(this.grapplingHook.x - item.x, this.grapplingHook.y - item.y) < item.radius + 5) {
                        return item; 
                    }
                }
                for (let rock of obstacles) {
                     if (Math.hypot(this.grapplingHook.x - rock.x, this.grapplingHook.y - rock.y) < rock.radius + 5) {
                        return { ...rock, isHeavy: true }; 
                    }
                }
                return null;
            }

            fireGrapple() {
                if (this.grapplingHook.active || subStats.energyCore < 5) return; 
                subStats.energyCore -= 5;
                this.grapplingHook.active = true;
                this.grapplingHook.x = this.x;
                this.grapplingHook.y = this.y;
                this.grapplingHook.targetX = mouse.worldX;
                this.grapplingHook.targetY = mouse.worldY;
                this.grapplingHook.state = 'firing';
                this.grapplingHook.length = 0;
                this.grapplingHook.attachedTo = null;
                playSound('grapple_fire');
            }

            releaseGrapple() {
                if (this.grapplingHook.active) {
                    this.grapplingHook.state = 'retracting';
                    this.grapplingHook.attachedTo = null;
                }
            }

            useSonar() {
                if (Date.now() - this.lastSonarTime < 5000 || subStats.energyCore < subStats.sonarEnergyCost) return; 
                subStats.energyCore -= subStats.sonarEnergyCost;
                this.lastSonarTime = Date.now();
                playSound('sonar_ping');
                particles.push(new Particle(this.x, this.y, subStats.sonarRange, `rgba(0, 200, 255, 0.5)`, null, 30, 'sonar_wave'));

                sonarPings = []; 
                const itemsToPing = [...collectibles, ...creatures, ...obstacles];
                itemsToPing.forEach(item => {
                    if (!item.collected && Math.hypot(this.x - item.x, this.y - item.y) < subStats.sonarRange) {
                        sonarPings.push({ x: item.x, y: item.y, radius: item.radius, type: item.constructor.name });
                    }
                });
            }

            useCurrentTool() {
                if (subStats.currentTool === 'hook') this.fireGrapple();
                else if (subStats.currentTool === 'sonar') this.useSonar();
            }

            switchTool() {
                this.releaseGrapple(); 
                if (subStats.currentTool === 'hook') subStats.currentTool = 'sonar';
                else subStats.currentTool = 'hook';
                toolDisplay.textContent = subStats.currentTool === 'hook' ? 'Hook' : 'Sonar';
                switchToolButton.textContent = subStats.currentTool === 'hook' ? 'Sonar' : 'Hook';
                touchToolActionButton.textContent = subStats.currentTool === 'hook' ? 'HOOK' : 'PING';
            }

            takeDamage(amount) {
                subStats.hullIntegrity -= amount;
                playSound('hull_damage');
                if (subStats.hullIntegrity <= 0) {
                    subStats.hullIntegrity = 0;
                    gameOver();
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.spotlightAngle + Math.PI / 2); 
                ctx.fillStyle = '#88aaff'; 
                ctx.strokeStyle = '#cceeff';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.arc(0, -this.radius * 0.7, this.radius * 0.6, Math.PI, 0); 
                ctx.rect(-this.radius*0.6, -this.radius*0.7, this.radius*1.2, this.radius*1.4);
                ctx.arc(0, this.radius * 0.7, this.radius * 0.6, 0, Math.PI); 
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#66ccff';
                ctx.beginPath();
                ctx.arc(0, -this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                if (this.grapplingHook.active) {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.grapplingHook.x, this.grapplingHook.y);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(this.grapplingHook.x, this.grapplingHook.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Collectible {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; 
                this.collected = false;
                this.valueRP = 0;
                this.valueShards = 0;
                this.valueSpecimens = 0; 
                this.isHeavy = false; 

                switch (type) {
                    case 'flora':
                        this.radius = 8 + Math.random() * 4;
                        this.color = `hsl(${100 + Math.random()*40}, 70%, 60%)`; 
                        this.valueRP = 1 + Math.floor(Math.random()*2);
                        break;
                    case 'treasure':
                        this.radius = 12 + Math.random() * 6;
                        this.color = '#FFD700'; 
                        this.valueShards = 5 + Math.floor(Math.random()*10);
                        this.isHeavy = true;
                        break;
                    case 'specimen': 
                        this.radius = 10 + Math.random() * 5;
                        this.color = `hsl(${200 + Math.random()*60}, 80%, 70%)`; 
                        this.valueRP = 3 + Math.floor(Math.random()*5);
                        this.valueSpecimens = 1;
                        break;
                }
            }

            update() { /* Maybe slight bobbing motion */ }

            draw(ctx, isLit) {
                if (this.collected) return;
                const baseAlpha = isLit ? 1 : AMBIENT_LIGHT_LEVEL + 0.1; 
                
                let tempColor = this.color;
                if (this.color.startsWith('#')) {
                    const r = parseInt(this.color.slice(1, 3), 16);
                    const g = parseInt(this.color.slice(3, 5), 16);
                    const b = parseInt(this.color.slice(5, 7), 16);
                    tempColor = `rgba(${r},${g},${b},${baseAlpha})`;
                } else if (this.color.startsWith('hsl')) {
                     tempColor = this.color.replace(/hsl\(([^,]+),([^,]+),([^)]+)\)/, (match, h, s, l) => `hsla(${h},${s},${l},${baseAlpha})`);
                }
                ctx.fillStyle = tempColor;


                ctx.beginPath();
                if (this.type === 'treasure') { 
                    ctx.rect(this.x - this.radius, this.y - this.radius * 0.7, this.radius * 2, this.radius * 1.4);
                } else if (this.type === 'specimen') { 
                    ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.7, 0, 0, Math.PI * 2);
                } else { 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                }
                ctx.fill();

                if (isLit && this.type !== 'treasure') { 
                    let brightCoreColor = this.color;
                    if (this.color.startsWith('#')) {
                        const r = parseInt(this.color.slice(1, 3), 16);
                        const g = parseInt(this.color.slice(3, 5), 16);
                        const b = parseInt(this.color.slice(5, 7), 16);
                        brightCoreColor = `rgba(${r},${g},${b},1)`; 
                    } else if (this.color.startsWith('hsl')) {
                         brightCoreColor = this.color.replace(/hsl\(([^,]+),([^,]+),([^)]+)\)/, (match, h, s, l) => `hsla(${h},${s},85%,1)`);
                    }
                    ctx.fillStyle = brightCoreColor;
                    ctx.beginPath();
                    if (this.type === 'specimen') ctx.ellipse(this.x, this.y, this.radius*0.5, this.radius*0.35, 0, 0, Math.PI * 2);
                    else ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            collect() {
                if (this.collected) return false;
                if (subStats.currentCargo + this.valueSpecimens > subStats.cargoCapacity && this.valueSpecimens > 0) {
                    showMessage("Cargo hold full for specimens!");
                    return false; 
                }

                this.collected = true;
                diveStats.rp += this.valueRP;
                diveStats.shards += this.valueShards;
                diveStats.specimens += this.valueSpecimens;
                subStats.currentCargo += this.valueSpecimens;

                if (this.type === 'flora') playSound('pickup_flora');
                else if (this.type === 'treasure') playSound('pickup_treasure');
                else if (this.type === 'specimen') playSound('pickup_specimen');
                return true;
            }
        }

        class Obstacle { 
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = `hsl(0, 0%, ${20 + Math.random()*15}%)`; 
                this.sides = Math.floor(Math.random() * 3) + 5; 
                this.offsets = [];
                for (let i = 0; i < this.sides; i++) {
                    this.offsets.push(Math.random() * this.radius * 0.3 - this.radius * 0.15);
                }
                this.isHeavy = true; 
            }
            draw(ctx, isLit) {
                const alpha = isLit ? 1 : AMBIENT_LIGHT_LEVEL; 
                ctx.fillStyle = this.color.replace(/hsl\(([^,]+),([^,]+),([^)]+)\)/, (match, h, s, l) => `hsla(${h},${s},${l},${alpha})`);
                ctx.strokeStyle = this.color.replace(/hsl\(([^,]+),([^,]+),([^)]+)\)/, (match, h, s, l) => `hsla(${h},${s},${parseFloat(l.replace('%','')) + 10}%,${alpha})`);
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.sides; i++) {
                    const angle = (i / this.sides) * Math.PI * 2;
                    const r = this.radius + this.offsets[i];
                    const xPos = this.x + r * Math.cos(angle);
                    const yPos = this.y + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(xPos, yPos);
                    else ctx.lineTo(xPos, yPos);
                }
                ctx.closePath();
                ctx.fill();
                if (isLit && alpha > 0.5) ctx.stroke(); 
            }
        }
         class Creature {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; 
                this.vel = { x: (Math.random() - 0.5) * 0.5, y: (Math.random() - 0.5) * 0.5 };
                this.target = null; 
                this.agroRadius = 100;
                this.attackDamage = 5;

                switch(type) {
                    case 'passive_small':
                        this.radius = 10 + Math.random() * 5;
                        this.color = `hsl(${Math.random()*360}, 60%, 70%)`;
                        break;
                    case 'aggressive_small':
                        this.radius = 12 + Math.random() * 6;
                        this.color = `hsl(${Math.random()*30}, 80%, 50%)`; 
                        this.agroRadius = 150 + subStats.spotlightRange * 0.3; 
                        break;
                }
            }

            update(submersible, isLit) {
                if (this.type === 'aggressive_small' && submersible) { 
                    const distToSub = Math.hypot(this.x - submersible.x, this.y - submersible.y);
                    if (distToSub < this.agroRadius && isLit) { 
                        this.target = submersible;
                        playSound('creature_agro');
                    } else if (distToSub > this.agroRadius * 1.5) {
                        this.target = null; 
                    }

                    if (this.target) {
                        const angleToTarget = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        this.vel.x += Math.cos(angleToTarget) * 0.05;
                        this.vel.y += Math.sin(angleToTarget) * 0.05;
                    }
                }

                this.x += this.vel.x;
                this.y += this.vel.y;
                this.vel.x *= 0.98;
                this.vel.y *= 0.98;
            }

            draw(ctx, isLit) {
                const alpha = isLit ? 1 : (this.type === 'aggressive_small' ? AMBIENT_LIGHT_LEVEL + 0.2 : AMBIENT_LIGHT_LEVEL); 
                ctx.fillStyle = this.color.replace(/hsl\(([^,]+),([^,]+),([^)]+)\)/, (match, h,s,l) => `hsla(${h},${s},${l},${alpha})`);
                ctx.beginPath();
                
                const angle = Math.atan2(this.vel.y, this.vel.x);
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);
                ctx.ellipse(0, 0, this.radius, this.radius * 0.6, 0, 0, Math.PI * 2);
                
                ctx.moveTo(-this.radius * 0.8, 0);
                ctx.lineTo(-this.radius * 1.5, -this.radius * 0.4);
                ctx.lineTo(-this.radius * 1.5, this.radius * 0.4);
                ctx.closePath();
                ctx.fill();
                if (isLit && this.type === 'aggressive_small') { 
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.radius * 0.4, -this.radius * 0.2, 2, 0, Math.PI * 2);
                    ctx.arc(this.radius * 0.4, this.radius * 0.2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }


        class Particle {
            constructor(x, y, radius, color, vel, lifespan = 60, type = 'spark') {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.vel = vel || { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                this.lifespan = lifespan; this.initialLifespan = lifespan; this.type = type;
            }
            update() {
                this.x += this.vel.x; this.y += this.vel.y;
                if (this.type !== 'sonar_wave') { this.vel.y += 0.05; } 
                this.vel.x *= 0.98; this.vel.y *= (this.type === 'sonar_wave' ? 1 : 0.98);
                this.lifespan--;
            }
            draw(ctx) {
                const alpha = Math.max(0, this.lifespan / this.initialLifespan);
                ctx.globalAlpha = alpha;
                if (this.type === 'sonar_wave') {
                    ctx.strokeStyle = this.color.replace(/rgba\(([^,]+,[^,]+,[^,]+),[^)]+\)/, (match, rgb) => `rgba(${rgb},${alpha*0.5})`);
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 - alpha), 0, Math.PI * 2); 
                    ctx.stroke();
                } else { 
                    ctx.fillStyle = this.color.replace(/rgba\(([^,]+,[^,]+,[^,]+),[^)]+\)/, (match, rgb) => `rgba(${rgb},${alpha})`);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => { messageBox.classList.remove('show'); }, duration);
        }
        function isElementInSpotlight(elementX, elementY, elementRadius) {
            if (!sub) return false;
            const distToSub = Math.hypot(elementX - sub.x, elementY - sub.y);
            if (distToSub > subStats.spotlightRange + elementRadius) return false;

            const angleToElement = Math.atan2(elementY - sub.y, elementX - sub.x);
            let angleDiff = Math.abs(sub.spotlightAngle - angleToElement);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; 

            return angleDiff <= subStats.spotlightWidth / 2 + Math.atan(elementRadius / distToSub); 
        }
        function worldToScreen(worldX, worldY) {
            return { x: worldX - camera.x + canvas.width / 2, y: worldY - camera.y + canvas.height / 2 };
        }
        function screenToWorld(screenX, screenY) {
            return { x: screenX + camera.x - canvas.width / 2, y: screenY + camera.y - canvas.height / 2 };
        }


        // --- Game Logic & State Management ---
        function initDive() {
            sub = new Submersible(canvas.width / 2, 50); 
            applyAllUpgrades(); 
            camera.x = sub.x;
            camera.y = sub.y;
            currentDepth = 0;
            diveStats = { rp: 0, shards: 0, specimens: 0 };
            subStats.currentCargo = 0;
            subStats.energyCore = subStats.maxEnergy; 
            subStats.hullIntegrity = subStats.maxHull; 

            collectibles = [];
            obstacles = [];
            creatures = [];
            particles = [];
            sonarPings = [];

            for (let i = 0; i < 20; i++) { 
                const yPos = 100 + Math.random() * 2000; 
                const xPos = camera.x + (Math.random() - 0.5) * 800; 
                if (Math.random() < 0.6) collectibles.push(new Collectible(xPos, yPos, 'flora'));
                else if (Math.random() < 0.85) collectibles.push(new Collectible(xPos, yPos, 'specimen'));
                else collectibles.push(new Collectible(xPos, yPos, 'treasure'));
            }
            for (let i = 0; i < 30; i++) {
                const yPos = 50 + Math.random() * 2000;
                const xPos = camera.x + (Math.random() - 0.5) * 1000;
                obstacles.push(new Obstacle(xPos, yPos, Math.random() * 40 + 20));
            }
             for (let i = 0; i < 5; i++) {
                const yPos = 500 + Math.random() * 1500; 
                const xPos = camera.x + (Math.random() - 0.5) * 800;
                creatures.push(new Creature(xPos, yPos, Math.random() < 0.3 ? 'aggressive_small' : 'passive_small'));
            }

            playSound('dive_start');
            updateUI();
        }

        function updateUI() {
            depthDisplay.textContent = `${currentDepth}m`;
            maxDepthDisplay.textContent = `${maxDepth}m`;
            energyDisplay.textContent = `${Math.floor(subStats.energyCore)}%`;
            hullDisplay.textContent = `${Math.floor(subStats.hullIntegrity)}%`;
            rpDisplay.textContent = subStats.researchPoints; 
            shardsDisplay.textContent = subStats.atlantiumShards; 
            cargoDisplay.textContent = `${subStats.currentCargo}/${subStats.cargoCapacity}`;
        }

        function showDiveSummary() {
            gameState = 'summary';
            subStats.researchPoints += diveStats.rp;
            subStats.atlantiumShards += diveStats.shards;
            if (currentDepth > maxDepth) {
                maxDepth = currentDepth;
                saveMaxDepth();
            }
            saveGameProgress(); 

            summaryDepth.textContent = currentDepth;
            summaryRP.textContent = diveStats.rp;
            summaryShards.textContent = diveStats.shards;
            summarySpecimens.textContent = diveStats.specimens; 
            diveSummaryScreen.style.display = 'flex';
        }

        function gameOver() {
            gameState = 'gameover';
            playSound('game_over_sound');
            finalDepthDisplay.textContent = currentDepth;
            if (currentDepth > maxDepth) { 
                maxDepth = currentDepth;
                saveMaxDepth();
            }
            gameOverScreen.style.display = 'flex';
        }

        function populateUpgradeScreen() {
            upgradeGrid.innerHTML = '';
            upgradesConfig.forEach(cfg => {
                const currentLevel = currentUpgradeLevels[cfg.id] || 0;
                const costMultiplier = Math.pow(1.8, currentLevel); 
                const costRP = Math.floor(cfg.baseCostRP * costMultiplier);
                const costShards = Math.floor(cfg.baseCostShards * costMultiplier);
                const statCurrentValue = cfg.baseValue + (cfg.increase * currentLevel);

                const itemDiv = document.createElement('div');
                itemDiv.className = 'upgrade-item';
                itemDiv.innerHTML = `
                    <h3>${cfg.name} (Lvl ${currentLevel})</h3>
                    <p>${cfg.desc} Current: ${statCurrentValue.toFixed(cfg.id === 'enginePower' || cfg.id === 'energyRegenRate' ? 3 : (cfg.id === 'spotlightWidth' ? 2: (cfg.id === 'maxHull' || cfg.id === 'maxEnergy' || cfg.id === 'cargoCapacity' || cfg.id === 'spotlightRange' || cfg.id === 'grappleRange' || cfg.id === 'sonarRange' || cfg.id === 'grappleSpeed' ? 0 : 1)) )}</p>
                    ${currentLevel < cfg.levels ? `
                        <p class="cost">Cost: ${costRP} RP, ${costShards} Shards</p>
                        <button class="button upgrade-button" data-id="${cfg.id}">Upgrade</button>
                    ` : '<p class="cost">Max Level</p>'}
                `;
                upgradeGrid.appendChild(itemDiv);
            });
            upgradeRPDisplay.textContent = subStats.researchPoints;
            upgradeShardsDisplay.textContent = subStats.atlantiumShards;

            document.querySelectorAll('.upgrade-button').forEach(button => {
                button.addEventListener('click', () => purchaseUpgrade(button.dataset.id));
            });
        }

        function purchaseUpgrade(upgradeId) {
            const config = upgradesConfig.find(u => u.id === upgradeId);
            if (!config) return;
            const currentLevel = currentUpgradeLevels[upgradeId] || 0;
            if (currentLevel >= config.levels) { showMessage("Max level reached."); return; }

            const costMultiplier = Math.pow(1.8, currentLevel);
            const costRP = Math.floor(config.baseCostRP * costMultiplier);
            const costShards = Math.floor(config.baseCostShards * costMultiplier);

            if (subStats.researchPoints >= costRP && subStats.atlantiumShards >= costShards) {
                subStats.researchPoints -= costRP;
                subStats.atlantiumShards -= costShards;
                currentUpgradeLevels[upgradeId] = currentLevel + 1;
                
                applyAllUpgrades(); 

                playSound('upgrade_purchase');
                populateUpgradeScreen(); 
                updateUI(); 
                saveGameProgress();
            } else {
                showMessage("Not enough resources!");
            }
        }

        // --- LocalStorage Save/Load ---
        function loadMaxDepth() {
            const storedMaxDepth = localStorage.getItem(MAX_DEPTH_KEY);
            if (storedMaxDepth) {
                maxDepth = parseInt(storedMaxDepth, 10) || 0;
            } else {
                maxDepth = 0;
            }
            maxDepthDisplay.textContent = `${maxDepth}m`;
        }
        function saveMaxDepth() {
            localStorage.setItem(MAX_DEPTH_KEY, maxDepth.toString());
        }
        function saveGameProgress() {
            const progressData = {
                researchPoints: subStats.researchPoints,
                atlantiumShards: subStats.atlantiumShards,
                currentUpgradeLevels: currentUpgradeLevels,
            };
            localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));
            console.log("Game progress saved to localStorage.");
        }
        function loadGameProgress() {
            upgradesConfig.forEach(cfg => { 
                if (typeof currentUpgradeLevels[cfg.id] === 'undefined') {
                    currentUpgradeLevels[cfg.id] = 0;
                }
            });

            const localData = localStorage.getItem(PROGRESS_KEY);
            let loadedFromStorage = false;
            if (localData) {
                try {
                    const data = JSON.parse(localData);
                    subStats.researchPoints = data.researchPoints || 0;
                    subStats.atlantiumShards = data.atlantiumShards || 0;
                    currentUpgradeLevels = data.currentUpgradeLevels || currentUpgradeLevels;
                    console.log("Game progress loaded from localStorage.");
                    loadedFromStorage = true;
                } catch (e) { console.error("Error parsing localStorage progress", e); }
            }
            
            if (!loadedFromStorage) { 
                 upgradesConfig.forEach(cfg => { currentUpgradeLevels[cfg.id] = 0; });
                 console.log("No saved progress found in localStorage, using defaults.");
            }
            applyAllUpgrades(); 
        }

        function applyAllUpgrades() {
            upgradesConfig.forEach(cfg => {
                const level = currentUpgradeLevels[cfg.id] || 0;
                subStats[cfg.id] = cfg.baseValue + (cfg.increase * level);
            });
            subStats.hullIntegrity = subStats.maxHull;
            subStats.energyCore = subStats.maxEnergy;
            updateUI(); 
        }


        // --- Main Game Loop ---
        function gameLoop() {
            startScreen.style.display = gameState === 'start' ? 'flex' : 'none';
            diveSummaryScreen.style.display = gameState === 'summary' ? 'flex' : 'none';
            gameOverScreen.style.display = gameState === 'gameover' ? 'flex' : 'none';
            upgradeScreen.style.display = gameState === 'upgrade' ? 'flex' : 'none';

            if (gameState !== 'playing') {
                ctx.fillStyle = '#000814'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                requestAnimationFrame(gameLoop);
                return;
            }
            if (!sub) { 
                console.error("Sub not initialized in gameLoop. Returning to start.");
                gameState = 'start';
                requestAnimationFrame(gameLoop);
                return;
            }


            sub.accel = {x:0, y:0}; 
            let isThrusting = false;
            if (keys['KeyW'] || keys['ArrowUp'] || touchInput.y < -0.2) { sub.accel.y = -subStats.enginePower; isThrusting = true;}
            if (keys['KeyS'] || keys['ArrowDown'] || touchInput.y > 0.2) { sub.accel.y = subStats.enginePower; isThrusting = true;}
            if (keys['KeyA'] || keys['ArrowLeft'] || touchInput.x < -0.2) { sub.accel.x = -subStats.enginePower; isThrusting = true;}
            if (keys['KeyD'] || keys['ArrowRight'] || touchInput.x > 0.2) { sub.accel.x = subStats.enginePower; isThrusting = true;}
            
            if (isThrusting && Tone.context.state === 'running') {
                 playSound('thruster_burst'); 
            }


            sub.update();

            camera.x += (sub.x - camera.x) * CAMERA_LERP_FACTOR;
            camera.y += (sub.y - camera.y) * CAMERA_LERP_FACTOR;

            collectibles.forEach(c => c.update());
            creatures.forEach(c => c.update(sub, isElementInSpotlight(c.x, c.y, c.radius)));
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.lifespan > 0);

            if (Math.random() < 0.02) { 
                const spawnY = camera.y + canvas.height / 2 + Math.random() * 100; 
                const spawnX = camera.x + (Math.random() - 0.5) * canvas.width * 1.5; 
                const typeRoll = Math.random();
                if (typeRoll < 0.05 && collectibles.length < 50) collectibles.push(new Collectible(spawnX, spawnY, 'treasure'));
                else if (typeRoll < 0.2 && collectibles.length < 50) collectibles.push(new Collectible(spawnX, spawnY, 'specimen'));
                else if (typeRoll < 0.5 && collectibles.length < 50) collectibles.push(new Collectible(spawnX, spawnY, 'flora'));
                else if (typeRoll < 0.8 && obstacles.length < 60) obstacles.push(new Obstacle(spawnX, spawnY, Math.random() * 30 + 15));
                else if (creatures.length < 10 && currentDepth > 300) creatures.push(new Creature(spawnX, spawnY, Math.random() < 0.4 ? 'aggressive_small' : 'passive_small'));
            }
            
            collectibles = collectibles.filter(c => c.y > camera.y - canvas.height * 1.5 && !c.collected); 
            obstacles = obstacles.filter(o => o.y > camera.y - canvas.height * 1.5);
            creatures = creatures.filter(cr => cr.y > camera.y - canvas.height * 1.5);


            obstacles.forEach(rock => {
                if (!sub) return; 
                const dist = Math.hypot(sub.x - rock.x, sub.y - rock.y);
                if (dist < sub.radius + rock.radius) {
                    sub.takeDamage(10); 
                    const angle = Math.atan2(sub.y - rock.y, sub.x - rock.x);
                    sub.vel.x = Math.cos(angle) * 1.5;
                    sub.vel.y = Math.sin(angle) * 1.5;
                }
            });
            
            collectibles.forEach(item => {
                if (item.collected || !sub) return; 
                const dist = Math.hypot(sub.x - item.x, sub.y - item.y);
                if (item.type === 'flora' && dist < sub.radius + item.radius + 10) { 
                    item.collect();
                }
            });
            collectibles = collectibles.filter(c => !c.collected);


            creatures.forEach(creature => {
                if (!sub) return; 
                const dist = Math.hypot(sub.x - creature.x, sub.y - creature.y);
                if (dist < sub.radius + creature.radius) {
                    if (creature.type.includes('aggressive')) {
                        sub.takeDamage(creature.attackDamage);
                        const angle = Math.atan2(creature.y - sub.y, creature.x - sub.x);
                        creature.vel.x = Math.cos(angle) * 2;
                        creature.vel.y = Math.sin(angle) * 2;
                    }
                }
            });

            ctx.save();
            ctx.translate(canvas.width / 2 - camera.x, canvas.height / 2 - camera.y);
            ctx.fillStyle = '#000814'; 
            ctx.fillRect(camera.x - canvas.width/2 - 20, camera.y - canvas.height/2 - 20, canvas.width + 40, canvas.height + 40); 


            ctx.save(); 
            if (sub) { 
                ctx.beginPath();
                ctx.moveTo(sub.x, sub.y);
                ctx.arc(sub.x, sub.y, subStats.spotlightRange, sub.spotlightAngle - subStats.spotlightWidth / 2, sub.spotlightAngle + subStats.spotlightWidth / 2);
                ctx.closePath();
                const lightGradient = ctx.createRadialGradient(sub.x, sub.y, subStats.spotlightRange * 0.05, sub.x, sub.y, subStats.spotlightRange);
                lightGradient.addColorStop(0, `rgba(230, 230, 200, ${AMBIENT_LIGHT_LEVEL + 0.15})`); 
                lightGradient.addColorStop(0.7, `rgba(200, 200, 170, ${AMBIENT_LIGHT_LEVEL + 0.1})`);
                lightGradient.addColorStop(1, `rgba(150, 150, 120, ${AMBIENT_LIGHT_LEVEL + 0.05})`); 
                ctx.fillStyle = lightGradient;
                ctx.fill(); 
                
                ctx.clip(); 
            }

            obstacles.forEach(o => o.draw(ctx, true)); 
            collectibles.forEach(c => c.draw(ctx, true));
            creatures.forEach(cr => cr.draw(ctx, true));

            ctx.restore(); 

            if (sub) {
                sub.draw(ctx); 
            }
            
            particles.forEach(p => p.draw(ctx));

            ctx.restore(); 

            drawMiniMap();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function drawMiniMap() {
            ctx.save();
            const mapSize = 100;
            const mapMargin = 10;
            const mapXPos = canvas.width - mapSize - mapMargin;
            const mapYPos = canvas.height - mapSize - mapMargin;

            ctx.translate(mapXPos, mapYPos); 
            
            ctx.fillStyle = "rgba(0,10,20,0.8)";
            ctx.fillRect(0,0,mapSize,mapSize);
            ctx.strokeStyle = "#3399ff";
            ctx.strokeRect(0,0,mapSize,mapSize);

            if (sub) { 
                const mapScale = 0.05; 
                
                ctx.fillStyle = "yellow"; 
                ctx.beginPath(); 
                ctx.arc(mapSize/2, mapSize/2, 3, 0, Math.PI*2); 
                ctx.fill();

                sonarPings.forEach(ping => {
                    const relX = ping.x - sub.x; 
                    const relY = ping.y - sub.y;
                    const displayX = mapSize/2 + relX * mapScale;
                    const displayY = mapSize/2 + relY * mapScale;
                    
                    if (displayX > 2 && displayX < mapSize-2 && displayY > 2 && displayY < mapSize-2) { 
                        ctx.fillStyle = ping.type === 'Collectible' ? 'lightgreen' : 
                                        ping.type === 'Obstacle' ? 'grey' : 
                                        (ping.type === 'Creature' ? 'red' : 'white');
                        ctx.beginPath(); 
                        ctx.arc(displayX, displayY, Math.max(1, (ping.radius || 5) * mapScale * 0.5), 0, Math.PI*2); 
                        ctx.fill();
                    }
                });
            }
            ctx.restore();
        }


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => { 
            keys[e.code] = true; 
            if (e.code === 'KeyQ' && sub) sub.switchTool(); 
        });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            if (sub) { 
                const worldPos = screenToWorld(mouse.x, mouse.y);
                mouse.worldX = worldPos.x;
                mouse.worldY = worldPos.y;
            }
        });
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { 
                mouse.down = true;
                if (gameState === 'playing' && sub) sub.useCurrentTool();
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouse.down = false;
                if (gameState === 'playing' && sub && subStats.currentTool === 'hook') sub.releaseGrapple();
            }
        });
        canvas.addEventListener('contextmenu', e => e.preventDefault());


        let touchInput = { x: 0, y: 0 }; 
        let joystickTouchId = null;
        let joystickCenter = { x: 0, y: 0 };

        touchJoystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (joystickTouchId === null) { 
                joystickTouchId = e.changedTouches[0].identifier;
                const rect = touchJoystickBase.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
                updateJoystick(e.changedTouches[0]);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => { 
            if (joystickTouchId !== null) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        e.preventDefault();
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => { 
            if (joystickTouchId !== null) {
                 for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        joystickTouchId = null;
                        resetJoystick();
                        break;
                    }
                }
            }
        }, { passive: false });

        function updateJoystick(touch) {
            const dx = touch.clientX - joystickCenter.x;
            const dy = touch.clientY - joystickCenter.y;
            const dist = Math.hypot(dx, dy);
            const maxDist = touchJoystickBase.offsetWidth / 3; 

            if (dist === 0) {
                touchInput = { x: 0, y: 0 };
                touchJoystickStick.style.transform = `translate(0px, 0px)`;
                return;
            }

            const clampedDist = Math.min(dist, maxDist);
            const angle = Math.atan2(dy, dx);

            touchInput.x = (Math.cos(angle) * clampedDist) / maxDist;
            touchInput.y = (Math.sin(angle) * clampedDist) / maxDist;

            touchJoystickStick.style.transform = `translate(${Math.cos(angle) * clampedDist}px, ${Math.sin(angle) * clampedDist}px)`;
        }
        function resetJoystick() {
            touchInput = { x: 0, y: 0 };
            touchJoystickStick.style.transform = `translate(0px, 0px)`;
            joystickTouchId = null;
        }

        touchToolActionButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing' && sub) sub.useCurrentTool();
        });
        touchToolActionButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameState === 'playing' && sub && subStats.currentTool === 'hook') sub.releaseGrapple();
        });
        touchSwitchToolButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing' && sub) sub.switchTool();
        });
        
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'playing' && sub && e.target === canvas) { 
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                mouse.x = touch.clientX - rect.left;
                mouse.y = touch.clientY - rect.top;
                const worldPos = screenToWorld(mouse.x, mouse.y);
                mouse.worldX = worldPos.x;
                mouse.worldY = worldPos.y;
            }
        }, { passive: false });


        startGameButton.addEventListener('click', async () => {
            try {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext started by user gesture on Begin Dive.");
                }
                if (!thrusterSound) { 
                    await setupSounds();
                }
                gameState = 'playing';
                initDive();
            } catch (error) {
                console.error("Error starting game:", error);
                showMessage("Error starting game. Audio/Controls might not work. Check console.");
                if (gameState !== 'playing') { 
                    gameState = 'playing';
                    initDive(); 
                }
            }
        });

        returnToBaseButton.addEventListener('click', () => { 
            gameState = 'upgrade';
            populateUpgradeScreen();
        });
        goToBaseButtonGameOver.addEventListener('click', () => { 
            gameState = 'upgrade';
            populateUpgradeScreen();
        });
        exitUpgradeScreenButton.addEventListener('click', async () => { 
             try { 
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                     if (!thrusterSound) await setupSounds();
                }
                gameState = 'playing'; 
                initDive();
            } catch (error) {
                console.error("Error starting new dive from upgrade screen:", error);
                gameState = 'playing'; 
                initDive();
            }
        });
        switchToolButton.addEventListener('click', () => { if(sub) sub.switchTool() });

        helpIcon.addEventListener('click', () => {
            helpTooltip.style.display = helpTooltip.style.display === 'block' ? 'none' : 'block';
        });
        
        document.addEventListener('click', (event) => {
            if (helpTooltip.style.display === 'block' && !helpIconContainer.contains(event.target)) {
                helpTooltip.style.display = 'none';
            }
        });


        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (sub) { 
                camera.x = sub.x;
                camera.y = sub.y;
            }
        }
        window.addEventListener('resize', resizeCanvas);


        window.onload = async () => {
            resizeCanvas();
            // Firebase initializeFirebase(); REMOVED
            // Instead, directly load progress from localStorage and set up sounds.
            loadMaxDepth(); // Load max depth from localStorage
            loadGameProgress(); // Load game progress from localStorage
            // Sounds will be set up on first user interaction (e.g. start button)
            gameLoop();
        };

    </script>
</body>
</html>
